<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Análisis de Evaluaciones por Subtema</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

    <style>
        
        /* == ESTILOS GLOBALES Y DE DISEÑO == */
        body { 	
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            background-color: #FAEBD7; 
            padding: 20px; 
            margin: 0; 	
        }
        
        .main-container { 	
            max-width: 1300px;
            margin: 0 auto; 
            padding: 0; 	
        }
        
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .header-actions {
            display: flex; 
            gap: 10px; 
        }

        h1.main-title { 	
            color: #020202; 
            font-size: 2.5em;
            font-weight: 600;
        }

        .panel { 	
            background-color: #f7f7f7; 
            border: 1px solid #020202;
            border-radius: 8px;
            padding: 25px; 	
            margin-bottom: 25px; 		
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        
        .panel h2 {
            color: #122b3d;
            font-size: 1.5em;
            margin-top: 0;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #0e0d0d;
        }

        /* Botones de navegación */
        .nav-link { 	
            padding: 8px 15px;
            font-weight: 500; 	
            border: 1px solid #ccc; 
            border-radius: 4px;
            cursor: pointer;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            transition: background-color 0.2s;
            white-space: nowrap; 
        }
        
        .nav-link.cargar-btn {
            /* Mantenemos el color rojo para que se destaque, ahora como "Regresar/Actividades" */
            color: #f0ecec; 
            background-color: #f80404; 
            border-color: #070707;
        }

        .nav-link:hover {
            opacity: 0.9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Botón de Acción */
        .submit-btn { 	
            width: 100%;
            height: 42px;
            padding: 0 12px; 	
            font-weight: bold; 	
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background-color: #28a745; 
            color: white;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: background-color 0.2s;
        }

        .submit-btn:hover {
            background-color: #218838;
        }

        /* ------------------------------------------- */
        /* ORGANIZACIÓN DEL PANEL DE CONTROL */
        /* ------------------------------------------- */
        .control-group-upload {
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
            margin-bottom: 20px;
        }

        .control-group-filters {
            display: flex;
            gap: 15px; 
            align-items: flex-start; 
            flex-wrap: wrap; 
        }
        
        .upload-input-group {
            width: 100%; 
            display: flex; 
            flex-direction: column;
        }

        .upload-input-group input[type="file"] {
            padding: 10px; 
            border: 1px solid #0a0a0a8e; 
            border-radius: 4px;
            background-color: white;
            font-size: 1em;
        }

        .filtro-grupo {
            flex: 1 1 200px; 
            min-width: 180px; 
            box-sizing: border-box;
        }

        .select-box select { 
            width: 100%;
            padding: 8px;
            border: 1px solid #0a0a0a8e;
            border-radius: 4px;
            background-color: white;
            font-size: 1em;
            height: 42px; 
            box-sizing: border-box;
        }
        
        /* Estilos para los contenedores de checkboxes (simulando selects) */
        .checkbox-list-container {
            border: 1px solid #0a0a0a8e;
            border-radius: 4px;
            background-color: white;
            min-height: 42px; 
            max-height: 120px; 
            overflow-y: auto;
            padding: 5px 10px; 
        }
        
        .checkbox-list-container.disabled {
            opacity: 0.5;
            pointer-events: none; 
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin: 4px 0;
            font-size: 0.95em;
        }

        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
        }

        .checkbox-item label {
            cursor: pointer;
            flex-grow: 1; 
        }

        /* Encabezados de filtros */
        .filtro-grupo h3 { 	
            color: #555;
            margin-top: 0; 	
            margin-bottom: 5px; 		
            font-size: 1.1em;
            font-weight: 600; 	
        }
        
        .btn-action-container {
            flex: 1 1 200px;
            display: flex;
            align-items: flex-end; 
            padding-top: 25px; 
        }
        
        /* Seccion de Resultados Dinámicos por Lección (Para Tablas de Muestra) */
        .lesson-results-section {
            border: 1px solid #ddd; 
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            background-color: #fff;
            box-shadow: 0 0 5px rgba(0,0,0,0.05);
        }

        .lesson-results-section h4.lesson-title-minor {
            color: #007bff;
            font-size: 1.4em;
            margin-top: 0;
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
            margin-bottom: 15px;
        }
        
        /* Contenedor principal para resultados consolidados */
        #unifiedResultsContainer {
            margin-top: 20px;
            padding-top: 10px;
        }
        
        /* Seccion de Resultados de la Tabla */
        .results-table-container {
            overflow-x: auto;
            margin-bottom: 30px;
        }

        .results-table-container table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 0.8em; 
        }
        
        .results-table-container th, .results-table-container td {
            border: 1px solid #ddd;
            padding: 6px 3px; 
            text-align: center;
            min-width: 40px; 
            max-width: 150px; 
            word-wrap: break-word;
        }
        .results-table-container th {
            background-color: #e3e3e3;
            font-weight: bold;
        }
        .correct { background-color: #e6ffe6; color: green; } 
        .incorrect { background-color: #ffe6e6; color: red; } 
        .leccion-header { background-color: #cceeff; font-size: 1.0em; } 
        .subtema-header { background-color: #99ccff; font-weight: bold; } 
        .nota-final { 
            background-color: #fffacd; 
            font-weight: bold; 
        } 
        .promedio-subtema { 
            background-color: #fce8d5; 
            font-weight: bold; 
            color: #cc6600; 
            min-width: 60px !important;
        }
        .student-info { 
            background-color: #e0f7fa; 
            font-weight: bold; 
            text-align: left !important; 
            min-width: 100px; 
        }
        .info-header { background-color: #ddd; }

        /* Estilos de Gráfico y Semáforo */
        .grafico-container { 	
            background-color: #ffffff;
            border: 1px solid #122b3d; 
            border-radius: 6px;
            padding: 10px; 	
            margin-top: 20px;
        }
        
        .indicadores-container, .estadisticas { 	
            margin-top: 30px; 	
            padding-top: 20px;
            border-top: 1px solid #eee; 
        }

        /* Estilos para el nuevo agrupamiento por Lección en el Semáforo (Punto 3) */
        .lesson-group-semaphore {
            margin-bottom: 30px;
            padding: 15px;
            border: 1px solid #ccc;
            border-radius: 6px;
            background-color: #f0f8ff;
        }

        .lesson-group-semaphore h3 {
            margin-top: 0;
            color: #0056b3;
            border-bottom: 2px solid #0056b3;
            padding-bottom: 5px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }
        
        .indicador { 	
            display: flex; 	
            align-items: center; 		
            margin-bottom: 10px; 		
            font-size: 0.9em;
        }
        .indicador-label { 	
            min-width: 350px; /* Más espacio para Curso y Subtema */
            font-weight: bold;
        }
        .progress-bar-bg { 	
            width: 70%;
            max-width: 700px; 	
            background-color: #f0f0f0; 	
            border: 1px solid #070707; 	
            height: 20px; 	
            display: flex; 	
            align-items: center;
        }
        .progress-bar { 
            height: 100%; 	
            text-align: right; 	
            padding-right: 5px; 
            color: rgb(0, 0, 0); 		
            box-sizing: border-box; 
            white-space: nowrap;
            font-weight: bold;
            font-size: 0.8em;
            line-height: 18px;
        }
        /* Colores del Semáforo */
        .indicador-red .progress-bar { background-color: #dc3545; color: white; } 	
        .indicador-yellow .progress-bar { background-color: #ffc107; } 	
        .indicador-green .progress-bar { background-color: #28a745; color: white; } 

        .estadistica-cursos-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .estadistica-item { 
            margin-bottom: 0; 	
            border: 1px solid #57545473;
            padding: 10px; 	
            flex: 1 1 300px;
            max-width: 48%; 
            box-sizing: border-box;
            border-radius: 4px;
            background-color: #f8f3e2;
        }
        
        /* Estilos específicos para el indicador de refuerzo GRUPAL (Punto 2) */
        .refuerzo-box {
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 6px;
            font-size: 1.0em;
            font-weight: 500;
        }
        .refuerzo-box.necesita {
            background-color: #ffe0b2; 
            border: 2px solid #ff9800; 
        }
        .refuerzo-box.adecuado {
            background-color: #e6ffe6; 
            border: 2px solid #28a745; 
        }
        .refuerzo-box strong {
            color: #d84315; 
            font-weight: bold;
        }
        .refuerzo-summary {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px dashed #ccc;
        }
        
    </style>
</head>
<body>

<div class="main-container">

    <div class="header-actions">
    <a href="resultados" class="nav-link cargar-btn">
        <i class="fas fa-list-alt"></i> Ir Actividades
    </a>
</div>
    
    <div id="controlPanel" class="panel">
        <h2>Menú de Control y Análisis</h2>
        
        <div class="control-group-upload">
            <div class="upload-input-group">
                <h3>1. Subir Archivo de Evaluaciones (.xlsx)</h3>
                <input type="file" id="excelFile" accept=".xls,.xlsx" required onchange="handleFileLoad(event)">
            </div>
        </div>

        <div class="control-group-filters">
            
            <div class="filtro-grupo">
                <h3>2. Lección </h3>
                <div id="lessonCheckboxesContainer" class="checkbox-list-container disabled">
                    <div class="checkbox-item">
                        <input type="checkbox" id="selectAllLessons" onchange="toggleSelectAll('lessonCheckboxesContainer', 'lessonOption', this.checked)">
                        <label for="selectAllLessons">Seleccionar Todas</label>
                    </div>
                </div>
            </div>
            
            <div class="filtro-grupo">
                <h3>3. Cursos Disponibles</h3>
                <div id="courseCheckboxesContainer" class="checkbox-list-container disabled">
                    <div class="checkbox-item">
                        <input type="checkbox" id="selectAllCourses" onchange="toggleSelectAll('courseCheckboxesContainer', 'courseOption', this.checked)">
                        <label for="selectAllCourses">Seleccionar Todos</label>
                    </div>
                </div>
            </div>

            <div class="filtro-grupo select-box">
                <h3>4. Tipo de Visualización</h3>
                <select id="tipoGraficoSelector">
                    <option value="barras" selected>Gráfico de Barras</option>
                    <option value="tendencias">Gráfico de Tendencias</option>
                </select>
            </div>
            
            <div class="btn-action-container">
                <button type="button" class="submit-btn" onclick="analyzeSelectedLessons()">
                    <i class="fas fa-chart-bar"></i> Generar Gráfico y Análisis 
                </button>
            </div>

        </div>
    </div>

    <div id="resultsSection" class="panel" style="display:none;">
        <h2>Resultados Comparativos</h2>
        
        <div id="unifiedResultsContainer">
            
            <h2 class="grafico-title">Gráfico de Rendimiento por Lección, Subtema y Curso</h2>
            <div id="graficoContainer_Unified" class="grafico-container"></div>
            
            <div id="refuerzoContainer_Unified" class="indicadores-container" style="margin-top: 20px;">
                <h2> Rendimiento Grupal por Lección y Subtema </h2>
                <div id="refuerzoList_Unified"></div>
            </div>

            <div id="indicadoresContainer_Unified" class="indicadores-container">
                <h2>Resumen de Promedios por Lección y Subtema </h2>
            </div>

            <div id="estadisticasContainer_Unified" class="estadisticas">
                <h2>Detalle de Distribución de Calificaciones por Lección/Subtema</h2>
            </div>
            
        </div>
        
        <hr style="border: 0; border-top: 3px solid #122b3d; margin: 40px 0;">

        <h3>Tablas de Notas por Lección (Muestra de 10 Estudiantes)</h3>
        <p style="font-size: 0.9em; color: #555;"></p>
        <div id="lessonResultsContainer">
            </div>

    </div>

    <div id="initial-message" class="panel" style="text-align: center; color: #555;">
        <i class="fas fa-database fa-3x" style="margin-bottom: 15px; color: #020202;"></i>
        <p>Suba un archivo de evaluación que contenga una o varias hojas (lecciones) para comenzar el análisis.</p>
        <p style="font-weight: bold;">Nota: La nota final se calcula en base a 20 preguntas donde cada acierto equivale a 0.5 puntos.</p>
    </div>

</div>

<script>
    let globalAllLessonsData = {}; 
    const POINTS_PER_CORRECT = 0.5; 
    const REINFORCEMENT_THRESHOLD = 7.0; 

    document.addEventListener('DOMContentLoaded', () => {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css';
        document.head.appendChild(link);
    });
    
    // --- LÓGICA DE CHECKBOXES (SIN CAMBIOS) ---

    function setCheckboxContainerDisabled(containerId, disabled) {
        const container = document.getElementById(containerId);
        if (container) {
            if (disabled) {
                container.classList.add('disabled');
                container.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.disabled = true);
            } else {
                container.classList.remove('disabled');
                container.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.disabled = false);
            }
        }
    }

    function toggleSelectAll(containerId, optionClass, checked) {
        const container = document.getElementById(containerId);
        if (!container) return;

        container.querySelectorAll(`input[type="checkbox"].${optionClass}`).forEach(checkbox => {
            checkbox.checked = checked;
        });

        const selectAllCheckbox = container.querySelector('input[type="checkbox"][id^="selectAll"]');
        if (selectAllCheckbox) {
            selectAllCheckbox.checked = checked;
        }
        
        if (containerId === 'lessonCheckboxesContainer') {
            updateCourseSelector();
        }
    }

    function synchronizeSelectAll(containerId, optionClass) {
        const container = document.getElementById(containerId);
        if (!container) return;

        const selectAllCheckbox = container.querySelector('input[type="checkbox"][id^="selectAll"]');
        if (!selectAllCheckbox) return;

        const individualCheckboxes = container.querySelectorAll(`input[type="checkbox"].${optionClass}`);
        const allChecked = Array.from(individualCheckboxes).every(cb => cb.checked);
        const anyChecked = Array.from(individualCheckboxes).some(cb => cb.checked);

        selectAllCheckbox.checked = allChecked;
        selectAllCheckbox.indeterminate = !allChecked && anyChecked;
        
        if (containerId === 'lessonCheckboxesContainer') {
            updateCourseSelector();
        }
    }

    function getSelectedValues(containerId, optionClass) {
        const container = document.getElementById(containerId);
        if (!container) return [];

        let selectedValues = Array.from(container.querySelectorAll(`input[type="checkbox"].${optionClass}:checked`))
                                    .map(checkbox => checkbox.value);
        
        if (selectedValues.length === 0 && container.classList.contains('disabled')) {
            return [];
        }
        
        const selectAllCheckbox = container.querySelector('input[type="checkbox"][id^="selectAll"]');
        if (selectAllCheckbox && selectAllCheckbox.checked && selectedValues.length > 0) {
             selectedValues = Array.from(container.querySelectorAll(`input[type="checkbox"].${optionClass}`))
                                .map(checkbox => checkbox.value);
        }

        return [...new Set(selectedValues)];
    }


    // --- LÓGICA DE CARGA Y POBLADO DE FILTROS ---

    function handleFileLoad(e) {
        const file = e.target.files[0];
        if (!file) { resetUI(); return; }

        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const data = new Uint8Array(e.target.result);
                // raw: true es importante para evitar que xlsx intente inferir tipos demasiado rápido en valores como 1
                const workbook = XLSX.read(data, {type: 'array', raw: true}); 
                
                globalAllLessonsData = {};
                let validSheetsCount = 0;
                
                workbook.SheetNames.forEach(name => {
                    const worksheet = workbook.Sheets[name];
                    const sheetData = XLSX.utils.sheet_to_json(worksheet, {header: 1, raw: true, range: 0}); 
                    
                    if (sheetData.length > 1) { 
                        globalAllLessonsData[name.trim()] = sheetData;
                        validSheetsCount++;
                    }
                });

                document.getElementById('initial-message').style.display = 'none';
                
                if (validSheetsCount > 0) {
                    const lessonNames = Object.keys(globalAllLessonsData);
                    populateLessonSelector(lessonNames);
                } else {
                    alert("⚠️ El archivo cargado no contiene hojas de cálculo válidas.");
                    resetUI();
                }

            } catch (error) {
                alert("⚠️ Error al procesar el archivo Excel. Asegúrese de que el formato sea correcto.");
                console.error(error);
                resetUI();
                document.getElementById('initial-message').style.display = 'block';
            }
        };
        reader.readAsArrayBuffer(file);
    }

    function resetUI() {
        globalAllLessonsData = {};
        
        const lessonContainer = document.getElementById('lessonCheckboxesContainer');
        const courseContainer = document.getElementById('courseCheckboxesContainer');
        
        // Reiniciar contenedor de lecciones
        lessonContainer.innerHTML = `<div class="checkbox-item">
                                        <input type="checkbox" id="selectAllLessons" onchange="toggleSelectAll('lessonCheckboxesContainer', 'lessonOption', this.checked)">
                                        <label for="selectAllLessons">Seleccionar Todas</label>
                                    </div>`;
        setCheckboxContainerDisabled('lessonCheckboxesContainer', true);

        // Reiniciar contenedor de cursos
        courseContainer.innerHTML = `<div class="checkbox-item">
                                        <input type="checkbox" id="selectAllCourses" onchange="toggleSelectAll('courseCheckboxesContainer', 'courseOption', this.checked)">
                                        <label for="selectAllCourses">Seleccionar Todos</label>
                                    </div>`;
        setCheckboxContainerDisabled('courseCheckboxesContainer', true);


        document.getElementById('resultsSection').style.display = 'none';
        document.getElementById('lessonResultsContainer').innerHTML = ''; 
        document.getElementById('initial-message').style.display = 'block';
    }

    function populateLessonSelector(lessonNames) {
        const container = document.getElementById('lessonCheckboxesContainer');
        
        let baseHtml = `<div class="checkbox-item">
                            <input type="checkbox" id="selectAllLessons" onchange="toggleSelectAll('lessonCheckboxesContainer', 'lessonOption', this.checked)">
                            <label for="selectAllLessons">Seleccionar Todas</label>
                        </div>`;
        container.innerHTML = baseHtml;
        
        if (lessonNames.length === 0) {
            setCheckboxContainerDisabled('lessonCheckboxesContainer', true);
            return;
        }

        lessonNames.forEach((name, index) => {
            const div = document.createElement('div');
            div.className = 'checkbox-item';
            // Al cambiar la selección de lección, forzamos la actualización de cursos llamando a updateCourseSelector()
            const onChangeAttr = `synchronizeSelectAll('lessonCheckboxesContainer', 'lessonOption');`; // updateCourseSelector() se llama dentro de synchronizeSelectAll
            div.innerHTML = `<input type="checkbox" id="lesson-${index}" class="lessonOption" value="${name}" onchange="${onChangeAttr}">
                             <label for="lesson-${index}">${name}</label>`;
            container.appendChild(div);
        });
        
        if (lessonNames.length > 0) {
            // Seleccionar la primera lección por defecto y forzar la actualización de cursos
            const firstLessonCheckbox = container.querySelector('.lessonOption');
            if (firstLessonCheckbox) {
                firstLessonCheckbox.checked = true;
            }
            synchronizeSelectAll('lessonCheckboxesContainer', 'lessonOption'); // Esto llama a updateCourseSelector()
            setCheckboxContainerDisabled('lessonCheckboxesContainer', false);
        }
    }
    
    /**
     * **CORRECCIÓN CRÍTICA**
     * Actualiza el selector de cursos leyendo *todas* las lecciones seleccionadas.
     */
    function updateCourseSelector() { 
        // Obtenemos todas las lecciones seleccionadas.
        const selectedLessons = getSelectedValues('lessonCheckboxesContainer', 'lessonOption');
        
        // Llamamos al populateCourseSelector con el array de lecciones
        populateCourseSelector(selectedLessons);
    }
    
    /**
     * **CORRECCIÓN CRÍTICA**
     * Popula el selector de cursos consolidando los cursos de *todas* las lecciones proporcionadas.
     * @param {string[]} lessonNames - Array de nombres de lecciones seleccionadas.
     */
    function populateCourseSelector(lessonNames) {
        const courseContainer = document.getElementById('courseCheckboxesContainer');
        
        let baseHtml = `<div class="checkbox-item">
                            <input type="checkbox" id="selectAllCourses" onchange="toggleSelectAll('courseCheckboxesContainer', 'courseOption', this.checked)">
                            <label for="selectAllCourses">Seleccionar Todos</label>
                        </div>`;
        courseContainer.innerHTML = baseHtml;
        setCheckboxContainerDisabled('courseCheckboxesContainer', true);
        
        if (lessonNames.length === 0) {
            return;
        }

        const allCourses = new Set();
        
        // 1. Iterar sobre todas las lecciones seleccionadas para obtener la lista maestra de cursos
        lessonNames.forEach(lessonName => {
            if (!globalAllLessonsData[lessonName]) return;
            
            const tempRawData = JSON.parse(JSON.stringify(globalAllLessonsData[lessonName]));
            
            const detectionResult = detectAndCleanHeaders(tempRawData);
            const cursoKey = detectionResult ? detectionResult.cursoKey : null;

            if (!detectionResult || !cursoKey) {
                return;
            }
            
            const dataStartRowIndex = detectionResult.headerRowIndex + (detectionResult.isDoubleHeader ? 2 : 1);
            const dataRows = tempRawData.slice(dataStartRowIndex);
            const headerRow = tempRawData[detectionResult.headerRowIndex + (detectionResult.isDoubleHeader ? 1 : 0)];
            const cursoIndex = headerRow.findIndex(h => h && h.toString().trim() === cursoKey);

            if (cursoIndex === -1) return;

            // Extraer cursos únicos de esta lección y agregarlos al Set consolidado
            dataRows.forEach(row => {
                const cursoValue = row[cursoIndex];
                if (cursoValue) {
                    const cursoTrimmed = cursoValue.toString().trim();
                    if (cursoTrimmed.length > 0) allCourses.add(cursoTrimmed);
                }
            });
        });

        // 2. Poblar el selector de cursos con la lista consolidada
        const cursos = Array.from(allCourses).sort(); 
        
        cursos.forEach((curso, index) => {
            const div = document.createElement('div');
            div.className = 'checkbox-item';
            div.innerHTML = `<input type="checkbox" id="course-${index}" class="courseOption" value="${curso}" onchange="synchronizeSelectAll('courseCheckboxesContainer', 'courseOption')">
                             <label for="course-${index}">${curso}</label>`;
            courseContainer.appendChild(div);
        });
        
        if (cursos.length > 0) {
            toggleSelectAll('courseCheckboxesContainer', 'courseOption', true);
            setCheckboxContainerDisabled('courseCheckboxesContainer', false);
        }
    }

    // --- FUNCIONES DE DETECCIÓN Y ANÁLISIS  ---
    // (Incluidas por completitud)

    function findHeaderRowIndex(data) {
        for (let i = 0; i < data.length; i++) {
            const row = data[i].map(h => h ? h.toString().trim().toLowerCase() : '');
            if (row.some(h => h.includes('cedula') || h.includes('nombre') || h.includes('curso') || h.includes('subtema'))) {
                return i;
            }
        }
        return -1;
    }

    function detectAndCleanHeaders(rawData) {
        let analysisStructure = {
            groupingStructure: {}, infoFields: [], groupingStructureKeys: [],
            cursoKey: '', cedulaKey: '', nombreKey: '', notaKey: '',
            headerRowIndex: -1, isDoubleHeader: false
        };
        
        analysisStructure.headerRowIndex = findHeaderRowIndex(rawData);
        if (analysisStructure.headerRowIndex === -1) return null;

        const h1 = rawData[analysisStructure.headerRowIndex].map(h => h ? h.toString().trim() : '');
        const h2 = (analysisStructure.headerRowIndex + 1 < rawData.length) ? rawData[analysisStructure.headerRowIndex + 1].map(h => h ? h.toString().trim() : '') : [];
        
        const hasPxInH2 = h2.some(h => h && h.startsWith('P') && !isNaN(parseInt(h.substring(1))));
        if (hasPxInH2 && detectDoubleHeaderInternal(h1, h2, analysisStructure)) { 
            analysisStructure.isDoubleHeader = true;
            return analysisStructure;
        }

        if (detectSingleCompositeHeaderInternal(h1, analysisStructure)) { 
            analysisStructure.isDoubleHeader = false;
            return analysisStructure;
        }
        
        return null;
    }
    
    function detectDoubleHeaderInternal(h1, h2, analysisStructure) {
        let currentSubtema = null;
        let foundPKeys = false; 

        for (let i = 0; i < Math.max(h1.length, h2.length); i++) {
            const field1 = h1[i] || ''; 
            const field2 = h2[i] || '';
            const lower1 = field1.toLowerCase();
            const lower2 = field2.toLowerCase();

            const isInfoField = lower1.includes('cedula') || lower1.includes('nombre') || lower1.includes('curso') || lower1.includes('total') || lower1.includes('nota') ||
                                lower2.includes('cedula') || lower2.includes('nombre') || lower2.includes('curso') || lower2.includes('total') || lower2.includes('nota');

            if (isInfoField) {
                const infoKey = field2 || field1;
                if(infoKey) {
                    const cleanedKey = infoKey.trim();
                    if (!analysisStructure.infoFields.includes(cleanedKey)) { analysisStructure.infoFields.push(cleanedKey); }
                    analysisStructure.groupingStructureKeys.push(cleanedKey);
                    currentSubtema = null;
                    
                    if (lower1.includes('curso') || lower2.includes('curso')) analysisStructure.cursoKey = cleanedKey;
                    if (lower1.includes('cedula') || lower2.includes('cedula')) analysisStructure.cedulaKey = cleanedKey;
                    if (lower1.includes('nombre') || lower2.includes('nombre')) analysisStructure.nombreKey = cleanedKey;
                    if (lower1.includes('total') || lower2.includes('total') || lower1.includes('nota') || lower2.includes('nota')) analysisStructure.notaKey = cleanedKey;
                }
                continue;
            }

            if (field2.startsWith('P') && !isNaN(parseInt(field2.substring(1)))) {
                foundPKeys = true;
                
                if (field1 && field1 !== currentSubtema) {
                    currentSubtema = field1; 
                }
                
                const subtemaKey = currentSubtema || 'Subtema Sin Nombre';
                if (!analysisStructure.groupingStructure[subtemaKey]) {
                    analysisStructure.groupingStructure[subtemaKey] = { count: 0, questions: [] };
                }
                analysisStructure.groupingStructure[subtemaKey].questions.push({key: field2, code: field2});
                analysisStructure.groupingStructureKeys.push(field2); 
                analysisStructure.groupingStructure[subtemaKey].count++;
            }
        }
        
        return foundPKeys && !!analysisStructure.cursoKey;
    }

    function detectSingleCompositeHeaderInternal(h1, analysisStructure) {
        const questionPattern = /(.+)\s*-\s*(P\d+)$/i; 
        let foundPKeys = false;

        for (const header of h1) {
            if (!header) continue;
            const match = header.match(questionPattern);
            const lower = header.toLowerCase();

            if (match) {
                foundPKeys = true;
                
                const subtemaKey = match[1].trim();
                const questionCode = match[2].trim();
                
                analysisStructure.groupingStructureKeys.push(header); 

                if (!analysisStructure.groupingStructure[subtemaKey]) {
                    analysisStructure.groupingStructure[subtemaKey] = { count: 0, questions: [] };
                }
                
                analysisStructure.groupingStructure[subtemaKey].questions.push({
                    key: header, 
                    code: questionCode,
                });
                analysisStructure.groupingStructure[subtemaKey].count++;

            } else {
                analysisStructure.infoFields.push(header);
                analysisStructure.groupingStructureKeys.push(header);

                if (lower.includes('curso')) analysisStructure.cursoKey = header;
                if (lower.includes('cedula')) analysisStructure.cedulaKey = header;
                if (lower.includes('nombre')) analysisStructure.nombreKey = header;
                if (lower.includes('total') || lower.includes('nota')) analysisStructure.notaKey = header;
            }
        }
        
        return foundPKeys && !!analysisStructure.cursoKey;
    }

    /**
     * Análisis por estudiante (rendimiento y nota final).
     */
    function analyzeData(studentData, structure) {
        const { groupingStructure, cursoKey, cedulaKey, nombreKey } = structure;
        
        return studentData.map(student => {
            let totalAciertos = 0;
            student.rendimientos = {}; 

            student.curso = cursoKey && student[cursoKey] ? student[cursoKey].toString().trim() : 'N/A';
            student.cedula = cedulaKey && student[cedulaKey] ? student[cedulaKey].toString().trim() : 'N/A';
            student.nombre = nombreKey && student[nombreKey] ? student[nombreKey].toString().trim() : 'N/A';
            
            for (const subtema in groupingStructure) {
                const group = groupingStructure[subtema];
                let subtemaAciertos = 0;
                
                group.questions.forEach(question => {
                    const questionKey = question.key; 
                    // Consideramos 1 o '1' como acierto
                    const acierto = student[questionKey] === 1 || student[questionKey] === '1' ? 1 : 0; 
                    
                    subtemaAciertos += acierto;
                    totalAciertos += acierto;
                    
                    student[questionKey + '_result'] = acierto;
                });

                const subtemaCount = group.count;
                // Rendimiento del subtema en escala 0-10
                student.rendimientos[subtema] = subtemaCount > 0 
                    ? (subtemaAciertos / subtemaCount * 10).toFixed(2)
                    : 'N/A';
            }
            
            student.totalAciertos = totalAciertos;
            student.notaFinal = (totalAciertos * POINTS_PER_CORRECT).toFixed(2);
            
            return student;
        }).filter(student => student.curso !== 'N/A' && student.nombre !== 'N/A');
    }

    /**
     * Generar el análisis estadístico CONSOLIDADO (Gráfico, Semáforo y Distribución).
     * * **MODIFICACIÓN CLAVE:** Ahora utiliza el array 'subtemaOrder' para garantizar el orden de aparición.
     */
    function generateStatisticalAnalysis(allAnalyzedData, selectedCourses) {
        
        const indicadores = {}; // Key: Leccion|Subtema|Curso -> { promedio, count, leccion, subtema, curso }
        const estadisticas = {}; // Key: Leccion|Subtema -> { Curso: { '0': count, ... '10': count } }
        const graficoData = { 
            cursos: selectedCourses, 
            data: [] // { x: Leccion|Subtema, y: promedio, curso: curso, leccion: leccion, subtema: subtema, studentsCount: count }
        };

        // Almacenar el orden de los subtemas para mantener la coherencia
        const lessonSubtemaOrder = {}; // Key: Leccion -> Array de Subtemas en orden

        allAnalyzedData.forEach(lessonResult => {
            const lessonName = lessonResult.lessonName;
            const students = lessonResult.analyzedData;
            const groupingStructure = lessonResult.structure.groupingStructure;
            
            // Determinar el orden de los subtemas para esta lección
            const subtemaOrder = determineSubtemaOrder(lessonResult.structure);
            lessonSubtemaOrder[lessonName] = subtemaOrder;

            // 1. Iterar sobre Cursos y Subtemas para consolidar métricas
            selectedCourses.forEach(curso => {
                const studentsInCourse = students.filter(s => s.curso === curso);
                
                // Usamos subtemaOrder para iterar en el orden correcto
                subtemaOrder.forEach(subtema => {
                    if (studentsInCourse.length === 0) return;

                    const key = `${lessonName}|${subtema}`; 
                    let totalSubtemaScore = 0;
                    
                    // Inicializar estructura de distribución
                    if (!estadisticas[key]) {
                        estadisticas[key] = {};
                    }
                    if (!estadisticas[key][curso]) {
                        estadisticas[key][curso] = {};
                        for (let i = 0; i <= 10; i++) estadisticas[key][curso][i.toString()] = 0;
                    }

                    studentsInCourse.forEach(student => {
                        // Asegurarse de que el subtema exista en rendimientos antes de parsear
                        const scoreStr = student.rendimientos[subtema];
                        const score = scoreStr !== 'N/A' ? parseFloat(scoreStr) : NaN;
                        if (isNaN(score)) return;

                        totalSubtemaScore += score;
                        
                        // Contar por nota entera del subtema (0-10)
                        const gradeBin = Math.min(10, Math.max(0, Math.floor(score))).toString(); 
                        estadisticas[key][curso][gradeBin] += 1;
                    });
                    
                    // 2. Indicators (Semáforo)
                    const average = studentsInCourse.length > 0 ? totalSubtemaScore / studentsInCourse.length : 0;
                    const indicadorKey = `${key}|${curso}`;
                    
                    indicadores[indicadorKey] = {
                        leccion: lessonName,
                        subtema: subtema,
                        curso: curso,
                        promedio: average,
                        count: studentsInCourse.length
                    };
                    
                    // 3. Graph Data
                    graficoData.data.push({
                        x: key, // Eje X unificado: Lección|Subtema
                        y: average,
                        curso: curso,
                        leccion: lessonName,
                        subtema: subtema,
                        displayText: `${lessonName} - ${subtema}`,
                        studentsCount: studentsInCourse.length // Añadido para el hover
                    });
                });
            });
        });
        
        // 4. Crear el ORDEN ÚNICO para el eje X y el renderizado (Lección y Subtema)
        const uniqueKeys = new Set();
        const sortedLessonKeys = Object.keys(lessonSubtemaOrder).sort(); // Ordenar por nombre de lección
        
        sortedLessonKeys.forEach(lessonName => {
            lessonSubtemaOrder[lessonName].forEach(subtema => {
                uniqueKeys.add(`${lessonName}|${subtema}`);
            });
        });
        
        const unifiedOrder = Array.from(uniqueKeys);

        // 5. Ordenar indicadores para el semáforo y refuerzo, usando la lista 'unifiedOrder'
        const sortedIndicators = Object.values(indicadores).sort((a, b) => {
            const keyA = `${a.leccion}|${a.subtema}`;
            const keyB = `${b.leccion}|${b.subtema}`;
            
            const indexA = unifiedOrder.indexOf(keyA);
            const indexB = unifiedOrder.indexOf(keyB);
            
            if (indexA !== indexB) return indexA - indexB; // Orden por posición en el archivo
            return a.curso.localeCompare(b.curso); // Desempate por curso
        });

        return { sortedIndicators, estadisticas, graficoData, unifiedOrder };
    }
    
    /**
     * Función auxiliar para extraer el orden de los subtemas.
     */
    function determineSubtemaOrder(structure) {
        if (structure.isDoubleHeader) {
            // En el caso de doble encabezado, los subtemas se toman de la fila superior (h1)
            // y se filtran los duplicados y campos de info, manteniendo el orden de aparición.
            const h1 = globalAllLessonsData[structure.leccionName][structure.headerRowIndex].map(h => h ? h.toString().trim() : '');
            
            const subtemaOrder = [];
            let lastSubtema = null;
            
            // Iterar sobre h1 y agregar solo el primer subtema en una serie de columnas combinadas
            for(let i = 0; i < h1.length; i++) {
                const subtemaName = h1[i];
                if (!subtemaName) continue;
                
                const lower = subtemaName.toLowerCase();
                const isInfoField = lower.includes('cedula') || lower.includes('nombre') || lower.includes('curso') || lower.includes('total') || lower.includes('nota');
                
                // Si NO es un campo de información y el nombre es diferente al anterior, es un nuevo subtema.
                if (!isInfoField && subtemaName !== lastSubtema) {
                    // Verificamos que este subtema tenga preguntas asociadas en la estructura final
                    if(structure.groupingStructure[subtemaName]) {
                         subtemaOrder.push(subtemaName);
                         lastSubtema = subtemaName;
                    } else {
                         lastSubtema = null; // Reset por si es un campo intermedio que no es subtema
                    }
                }
            }
            return subtemaOrder;

        } else {
            // En el caso de encabezado simple, los nombres de los subtemas se obtienen de las claves del objeto groupingStructure,
            // pero el orden se debe inferir del orden de los 'questions' dentro de la estructura general.
            const subtemaSet = new Set();
            const orderedSubtemas = [];
            
            for (const key of structure.groupingStructureKeys) {
                const match = key.match(/(.+)\s*-\s*(P\d+)$/i); // Patron Subtema - Px
                if (match) {
                    const subtemaName = match[1].trim();
                    if (!subtemaSet.has(subtemaName)) {
                        orderedSubtemas.push(subtemaName);
                        subtemaSet.add(subtemaName);
                    }
                }
            }
            return orderedSubtemas;
        }
    }


    // --- FUNCIÓN PRINCIPAL ORCHESTRADORA (COMPARATIVA) ---
    
    function analyzeSelectedLessons() {
        const selectedLessons = getSelectedValues('lessonCheckboxesContainer', 'lessonOption');
        const selectedCourses = getSelectedValues('courseCheckboxesContainer', 'courseOption'); 
        const sampleTablesContainer = document.getElementById('lessonResultsContainer');
        sampleTablesContainer.innerHTML = '';
        document.getElementById('resultsSection').style.display = 'none';
        
        if (selectedLessons.length === 0 || selectedCourses.length === 0) {
            alert("Seleccione al menos una lección y un curso para analizar.");
            return;
        }
        
        document.getElementById('resultsSection').style.display = 'block';
        
        let allAnalyzedData = []; // Array para almacenar los resultados de cada lección
        let totalStudentsFiltered = 0;

        selectedLessons.forEach((lessonName) => {
            const rawData = JSON.parse(JSON.stringify(globalAllLessonsData[lessonName])); 
            
            const structure = detectAndCleanHeaders(rawData);
            
            if (!structure) {
                sampleTablesContainer.innerHTML += `<div class="lesson-results-section"><h4 class="lesson-title-minor">${lessonName}</h4><p style="color: red; font-weight: bold;">⚠️ Error: No se pudo detectar la estructura de encabezados en esta lección. El análisis para esta hoja se ha omitido.</p></div>`;
                return;
            }
            
            // Asignar el nombre de la lección a la estructura
            structure.leccionName = lessonName;

            // Extracción de datos de estudiantes
            const dataStartRowIndex = structure.headerRowIndex + (structure.isDoubleHeader ? 2 : 1);
            const dataMappingHeaders = rawData[structure.headerRowIndex + (structure.isDoubleHeader ? 1 : 0)]; 
            
            const studentData = rawData.slice(dataStartRowIndex).map(row => {
                const student = {};
                row.forEach((value, index) => {
                    const key = dataMappingHeaders[index];
                    if (key) {
                        const cleanKey = key.toString().trim();
                        // Conversión robusta a número
                        if (cleanKey && 
                            (typeof value === 'number' || (typeof value === 'string' && !isNaN(parseFloat(value)) && parseFloat(value).toString().trim() === value.trim()))) {
                            student[cleanKey] = parseFloat(value); 
                        } else {
                            student[cleanKey] = value;
                        }
                    }
                });
                return student;
            });

            // 1. Análisis de datos por estudiante
            const analyzedData = analyzeData(studentData, structure);
            
            // 2. Filtrado por curso(s) seleccionado(s)
            let filteredData = analyzedData.filter(student => selectedCourses.includes(student.curso));

            if (filteredData.length > 0) {
                allAnalyzedData.push({ lessonName, analyzedData: filteredData, structure });
                totalStudentsFiltered += filteredData.length;
                
                // 3. Renderizar la TABLA DE MUESTRA de esta lección (separada)
                renderResultsTable(lessonName, filteredData, structure.groupingStructure, structure); // Se pasa 'structure'
            } else {
                sampleTablesContainer.innerHTML += `<div class="lesson-results-section"><h4 class="lesson-title-minor">${lessonName}</h4><p>⚠️ No se encontraron estudiantes en los cursos seleccionados (${selectedCourses.join(', ')}) para esta lección.</p></div>`;
            }
        });
        
        if (allAnalyzedData.length === 0) {
            document.getElementById('resultsSection').style.display = 'none';
            alert("No se encontraron datos válidos en las lecciones/cursos seleccionados para realizar el análisis consolidado.");
            return;
        }

        // 4. Generación de Análisis Estadístico CONSOLIDADO
        const analysisResults = generateStatisticalAnalysis(allAnalyzedData, selectedCourses);
        
        // 5. Renderizado de las secciones consolidadas
        renderCharts_Unified(analysisResults.graficoData, analysisResults.unifiedOrder); // Se pasa 'unifiedOrder'
        renderIndicators_Unified(analysisResults.sortedIndicators); 
        renderRefuerzoList_Unified(analysisResults.sortedIndicators); 
        renderEstadisticas_Unified(analysisResults.estadisticas, selectedCourses, analysisResults.unifiedOrder); // Se pasa 'unifiedOrder'
    }


    // --- FUNCIONES DE RENDERIZADO PARA RESULTADOS CONSOLIDADOS (UNIFIED) ---
    
    /**
     * Función de renderizado de tabla. **AJUSTADA para usar el orden correcto de subtemas**
     */
    function renderResultsTable(lessonName, data, groupingStructure, structure) { 
        const tableContainer = document.getElementById(`lessonResultsContainer`);
        const sanitizedLessonName = lessonName.replace(/[^a-zA-Z0-9]/g, '_');
        
        let sectionHtml = `<div id="tableSection_${sanitizedLessonName}" class="lesson-results-section">
                                <h4 class="lesson-title-minor">Lección: ${lessonName} (Estudiantes filtrados: ${data.length})</h4>
                                <div id="tableContainer_${sanitizedLessonName}" class="results-table-container"></div>
                            </div>`;
        tableContainer.insertAdjacentHTML('beforeend', sectionHtml);

        const currentTableContainer = document.getElementById(`tableContainer_${sanitizedLessonName}`);
        
        // Obtener el orden de los subtemas para esta lección
        const subtemaColumns = determineSubtemaOrder(structure);

        const totalSubtemaPromedioColumns = subtemaColumns.length;
        // Calcular el número total de columnas de preguntas según el orden de los subtemas
        const allQuestionsOrdered = subtemaColumns.flatMap(subtema => groupingStructure[subtema].questions);
        const totalQuestionColumns = allQuestionsOrdered.length;
        const totalColumns = 3 + totalQuestionColumns + totalSubtemaPromedioColumns;
        
        // Creación de encabezados
        let questionHeaderHtml = '';
        let subtemaHeaderHtml = '';
        let questionCodeHeaderHtml = '';
        
        subtemaColumns.forEach(subtema => {
            const count = groupingStructure[subtema].count;
            subtemaHeaderHtml += `<th class="subtema-header" colspan="${count}">${subtema}</th>`;
            groupingStructure[subtema].questions.forEach(q => {
                questionCodeHeaderHtml += `<th style="font-size: 0.7em;">${q.code}</th>`;
            });
            questionHeaderHtml += `<th class="promedio-subtema">${subtema}</th>`;
        });
        
        const headerHtml = `<table>
                            <tr>
                                <th class="info-header" colspan="3">Información del Estudiante</th>
                                <th class="leccion-header" colspan="${totalQuestionColumns}">Preguntas (1=Acierto)</th>
                                <th class="leccion-header" colspan="${totalSubtemaPromedioColumns}">Promedio Subtema (0-10)</th>
                                <th class="nota-final" rowspan="2">Nota Final</th>
                            </tr>
                            <tr>
                                <th class="student-info">Cédula</th>
                                <th class="student-info">Nombre</th>
                                <th class="student-info">Curso</th>
                                ${subtemaHeaderHtml}
                                ${questionHeaderHtml}
                                <th></th>
                            </tr>
                            <tr>
                                <th colspan="3"></th>
                                ${questionCodeHeaderHtml}
                                ${subtemaColumns.map(subtema => `<th class="promedio-subtema">Prom.</th>`).join('')}
                                <th></th>
                            </tr>`;
                            
        // Creación de filas de datos
        let bodyHtml = data.slice(0, 10).map(student => { 
            let rowHtml = `<tr>
                <td class="student-info">${student.cedula}</td>
                <td class="student-info" style="text-align: left !important;">${student.nombre}</td>
                <td class="student-info">${student.curso}</td>`;
            
            let promedioSubtemasHtml = '';

            // Iterar sobre los subtemas en el ORDEN correcto
            subtemaColumns.forEach(subtema => {
                const group = groupingStructure[subtema];
                group.questions.forEach(question => {
                    const result = student[question.key + '_result'];
                    const resultClass = result === 1 ? 'correct' : 'incorrect';
                    rowHtml += `<td class="${resultClass}">${result}</td>`;
                });
                promedioSubtemasHtml += `<td class="promedio-subtema">${student.rendimientos[subtema]}</td>`;
            });
            
            rowHtml += promedioSubtemasHtml;
            rowHtml += `<td class="nota-final">${student.notaFinal}</td></tr>`;
            return rowHtml;
        }).join('');

        if (data.length > 10) {
             bodyHtml += `<tr><td colspan="${totalColumns + 1}" style="text-align: center; font-style: italic;">... Se muestran las primeras 10 filas de ${data.length} estudiantes filtrados.</td></tr>`;
        } else if (data.length === 0) {
            bodyHtml = `<tr><td colspan="${totalColumns + 1}" style="text-align: center;">No se encontraron estudiantes.</td></tr>`;
        }

        currentTableContainer.innerHTML = headerHtml + bodyHtml + '</table>'; 
    }

    /**
     * FUNCIÓN MODIFICADA: Ahora usa 'unifiedOrder' para el eje X.
     */
    function renderCharts_Unified(graficoData, unifiedOrder) { 
        const chartDiv = document.getElementById(`graficoContainer_Unified`);
        const tipoGrafico = document.getElementById('tipoGraficoSelector').value;
        const traces = [];
        
        // 1. Usar unifiedOrder para el orden de las categorías del eje X
        const displayKeys = unifiedOrder.map(key => key.replace('|', ' - '));
        
        const colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf']; 
        let colorIndex = 0;

        graficoData.cursos.forEach(curso => {
            const courseData = graficoData.data.filter(d => d.curso === curso);
            
            // 2. Mapear los datos al orden correcto del eje X
            const avgScores = unifiedOrder.map(key => {
                const dataPoint = courseData.find(d => d.x === key);
                return dataPoint ? dataPoint.y : 0; 
            });

            // 3. Crear el array de hovertext en el orden correcto
            const hoverText = unifiedOrder.map(key => {
                const dataPoint = courseData.find(d => d.x === key);
                if (dataPoint) {
                    return `<b>Lección:</b> ${dataPoint.leccion}<br>` +
                           `<b>Subtema:</b> ${dataPoint.subtema}<br>` +
                           `<b>Promedio:</b> ${dataPoint.y.toFixed(2)} / 10<br>` +
                           `<b>Curso:</b> ${dataPoint.curso}<br>` +
                           `<b>Estudiantes:</b> ${dataPoint.studentsCount}<extra></extra>`;
                }
                // Retornar información menos detallada si no hay datos 
                return `Sin datos para ${curso} en este subtema.<extra></extra>`;
            });


            const trace = {
                x: displayKeys, 
                y: avgScores,
                name: `Curso: ${curso}`,
                type: tipoGrafico === 'barras' ? 'bar' : 'scatter',
                mode: tipoGrafico === 'tendencias' ? 'lines+markers' : undefined,
                marker: { color: colors[colorIndex++ % colors.length] },
                hovertemplate: hoverText,
                hoverinfo: 'text' 
            };
            traces.push(trace);
        });

        const layout = {
            title: `Comparativa de Promedios por Lección y Subtema`,
            xaxis: { 
                title: 'Lección - Subtema', 
                tickangle: -45, 
                automargin: true,
                categoryorder: 'array',
                categoryarray: displayKeys // Forzamos el orden del array
            },
            yaxis: { 
                title: 'Promedio (0-10)', 
                range: [0, 10] 
            },
            barmode: 'group',
            height: 600,
            margin: { t: 50, b: 200, l: 50, r: 20 }
        };

        Plotly.newPlot(chartDiv, traces, layout, {responsive: true});
    }

    /**
     * Se usa la lista de indicadores ya ordenados ('sortedIndicators').
     * No necesita 'unifiedOrder' directamente, pero se asegura que la agrupación por lección y subtema
     * respete el orden cronológico.
     */
    function renderIndicators_Unified(sortedIndicators) { 
        const container = document.getElementById(`indicadoresContainer_Unified`);
        container.innerHTML = '<h2>Resumen de Promedios por Lección y Subtema (Semáforo Comparativo)</h2>';
        
        if (sortedIndicators.length === 0) {
            container.innerHTML += '<p style="text-align: center;">No hay datos de lecciones y subtemas para generar el semáforo.</p>';
            return;
        }
        
        // 1. Agrupar por Lección para la estructura de la página
        const groupedByLesson = sortedIndicators.reduce((acc, item) => {
            const lessonKey = item.leccion;
            if (!acc[lessonKey]) acc[lessonKey] = [];
            acc[lessonKey].push(item);
            return acc;
        }, {});

        const sortedLessonKeys = Object.keys(groupedByLesson).sort();
        
        sortedLessonKeys.forEach(lessonKey => {
            const itemsInLesson = groupedByLesson[lessonKey];
            
            let lessonHtml = `<div class="lesson-group-semaphore">
                                <h3>Lección: ${lessonKey}</h3>`;
            
            // 2. Re-agrupar internamente por Subtema. Dado que 'itemsInLesson' ya está ordenado por subtema
            // debido al 'unifiedOrder', el orden se mantendrá si iteramos en el orden de aparición.
            
            // Creamos un Set de los subtemas en el orden en que aparecen en 'itemsInLesson'
            const subtemaOrder = Array.from(new Set(itemsInLesson.map(item => item.subtema)));
            
            subtemaOrder.forEach(subtemaKey => {
                // Filtramos los items de ese subtema (que ya estarán ordenados por curso)
                const itemsInSubtema = itemsInLesson.filter(item => item.subtema === subtemaKey);
                
                // Título del Subtema
                lessonHtml += `<h4 style="margin-top: 15px; margin-bottom: 10px; color: #444;">Subtema: ${subtemaKey}</h4>`;

                itemsInSubtema.forEach(item => {
                    const percentage = (item.promedio / 10) * 100;
                    let colorClass = 'indicador-green';
                    if (item.promedio < 7.0) colorClass = 'indicador-yellow';
                    if (item.promedio < 5.0) colorClass = 'indicador-red';
                    
                    const barColor = colorClass === 'indicador-red' ? '#dc3545' : colorClass === 'indicador-yellow' ? '#ffc107' : '#28a745';
                    const textColor = colorClass === 'indicador-yellow' ? 'black' : 'white';

                    lessonHtml += `<div class="indicador ${colorClass}">
                                <span class="indicador-label">Curso: ${item.curso} (${item.count} est.):</span>
                                <div class="progress-bar-bg">
                                    <div class="progress-bar" style="width: ${percentage.toFixed(0)}%; background-color: ${barColor}; color: ${textColor};">
                                        ${item.promedio.toFixed(2)}
                                    </div>
                                </div>
                            </div>`;
                });
            });

            lessonHtml += `</div>`;
            container.innerHTML += lessonHtml;
        });
    }

    /**
     * MODIFICACIÓN: Ahora usa la lista de indicadores ya ordenados ('sortedIndicators').
     * No necesita 'unifiedOrder' directamente.
     */
    function renderRefuerzoList_Unified(sortedIndicators) { 
        const refuerzoContainer = document.getElementById(`refuerzoList_Unified`);
        refuerzoContainer.innerHTML = '';
        
        if (sortedIndicators.length === 0) {
            refuerzoContainer.innerHTML = '<p style="text-align: center;">No hay datos para generar el resumen de rendimiento grupal.</p>';
            return;
        }

        let cursoRefuerzoHtml = '<div class="estadistica-cursos-container">';

        // 1. Agrupar los indicadores por CURSO
        const groupedByCourse = sortedIndicators.reduce((acc, item) => {
            const curso = item.curso;
            if (!acc[curso]) acc[curso] = [];
            acc[curso].push(item);
            return acc;
        }, {});
        
        // 2. Renderizar un box para cada curso
        // La lista 'itemsInCourse' ya está ordenada por Lección y Subtema gracias a 'sortedIndicators'
        Object.keys(groupedByCourse).sort().forEach(curso => {
            const itemsInCourse = groupedByCourse[curso]; 
            
            const weakSubtemas = itemsInCourse.filter(item => item.promedio < REINFORCEMENT_THRESHOLD);
            const adequateSubtemas = itemsInCourse.filter(item => item.promedio >= REINFORCEMENT_THRESHOLD);

            cursoRefuerzoHtml += `<div class="estadistica-item refuerzo-box ${weakSubtemas.length > 0 ? 'necesita' : 'adecuado'}">`;
            cursoRefuerzoHtml += `<h4>Curso: ${curso}</h4>`;
            
            if (weakSubtemas.length > 0) {
                cursoRefuerzoHtml += `<p style="font-weight: bold; color: #dc3545;">🚨 RENDIMIENTO BAJO (Promedio Grupal &lt; ${REINFORCEMENT_THRESHOLD.toFixed(1)}):</p><ul>`;
                
                weakSubtemas.forEach(item => {
                    cursoRefuerzoHtml += `<li>${item.leccion} - ${item.subtema} (Promedio: ${item.promedio.toFixed(2)}/10)</li>`;
                });
                cursoRefuerzoHtml += `</ul>`;
            } else {
                 cursoRefuerzoHtml += `<p style="color: green; font-weight: bold;">✅ RENDIMIENTO ADECUADO: No se detectan promedios grupales bajos.</p>`;
            }

            // Mostrar también los subtemas adecuados si hay bajos, para contraste
            if (weakSubtemas.length > 0 && adequateSubtemas.length > 0) {
                 cursoRefuerzoHtml += `<p style="font-weight: bold; color: #28a745; margin-top: 10px; border-top: 1px dashed #ccc; padding-top: 10px;">✅ RENDIMIENTO ADECUADO:</p><ul>`;
                 adequateSubtemas.forEach(item => {
                    // El orden de la lista 'adequateSubtemas' ya es cronológico (por lección/subtema)
                    cursoRefuerzoHtml += `<li>${item.leccion} - ${item.subtema} (Promedio: ${item.promedio.toFixed(2)}/10)</li>`;
                });
                cursoRefuerzoHtml += `</ul>`;
            }

            cursoRefuerzoHtml += `</div>`;
        });
        
        cursoRefuerzoHtml += '</div>';
        refuerzoContainer.innerHTML += cursoRefuerzoHtml;
    }


    /**
     * FUNCIÓN MODIFICADA: Ahora usa 'unifiedOrder' para iterar las estadísticas.
     */
    function renderEstadisticas_Unified(estadisticas, coursesToAnalyze, unifiedOrder) { 
        const container = document.getElementById(`estadisticasContainer_Unified`);
        let html = '<div class="estadistica-cursos-container">';
        
        if (Object.keys(estadisticas).length === 0) {
            container.innerHTML += '<p style="text-align: center;">No hay datos de distribución de calificaciones para generar estadísticas.</p>';
            return;
        }

        // Iterar usando el orden cronológico
        unifiedOrder.forEach(key => { // Key: Leccion|Subtema
            const [leccion, subtema] = key.split('|');
            const distributionByCourse = estadisticas[key];
            
            // Si no hay distribución (ej. promedio fue 0 porque no hubo estudiantes), se salta.
            if (!distributionByCourse) return;

            html += `<div class="estadistica-item">
                        <p style="font-size: 1.1em; font-weight: bold; color: #122b3d; border-bottom: 1px dotted #ccc; padding-bottom: 5px;">Distribución: ${leccion} - ${subtema}</p>`;
            
            coursesToAnalyze.forEach(curso => {
                const distribution = distributionByCourse[curso];
                if (!distribution) return;

                const totalStudents = Object.values(distribution).reduce((a, b) => a + b, 0);
                
                html += `<h5 style="margin: 10px 0 5px;">Curso: ${curso} (Total: ${totalStudents})</h5><ul style="list-style: none; padding: 0; margin: 0;">`;
                
                for (let i = 0; i <= 10; i++) {
                    const count = distribution[i.toString()] || 0;
                    const percentage = totalStudents > 0 ? (count / totalStudents) * 100 : 0;
                    
                    html += `<li style="display: flex; justify-content: space-between; font-size: 0.9em; border-bottom: 1px solid #f0f0f0;">
                                <span>Nota ${i}/10:</span>
                                <span>${count} (${percentage.toFixed(1)}%)</span>
                            </li>`;
                }
                html += '</ul>';
            });
            
            html += `</div>`;
        });
        
        html += '</div>';
        container.innerHTML = html;
    }
</script>
</body>
</html>
